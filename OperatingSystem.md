# 操作系统

## 进程和线程

### 1.什么是进程？

进程是系统进行资源分配和调度的一个独立单位，是系统中并发执行的单位

### 2.什么是线程？

线程是进程的一个实体，也是CPU调度和分派的基本单位。

### 3.进程和线程的区别？

1. 进程是资源分配的最小单位，而线程是CPU调度的最小单位
2. 创建进程和撤销进程的开销大于线程的开销
3. 不同进程的地址空间是独立的，同一进程内的线程共享同一地址空间，不同进程内的线程是不可见的
4. 进程间不会相互影响，而一个线程挂掉可能会导致整个进程挂掉

### 4.为什么有了进程，还需要线程

进程可以使多个程序并发执⾏，以提高资源的利用率和系统的吞吐量，但是其带来了一些缺点:
1. 进程在同⼀时间只能⼲一件事情;
2. 进程在执⾏的过程中如果阻塞，整个进程就会被挂起，
即使进程中有些⼯作不依赖与等待的资源，仍然不会执行。

基于以上的缺点，操作系统引⼊了了进程粒度更小的线程，作为并发执行的基本单位，
从而减少程序在并发执⾏时所付出的时间和空间开销，提⾼高并发性能。


### 5.进程的状态转换

+ 创建状态：进程正在被创建，还未到就绪状态
+ 就绪状态：进程已处于准备运行状态，获得了除cpu以外的所有资源
+ 运行状态：进程正在cpu上运行
+ 阻塞状态：进程正在等待某一事件而暂停运行如等待某资源可用或IO事件完成
+ 结束状态：进程正从系统中消失

### 6.进程间的通信方式

进程间的通信是在不同的进程之间传播或交换信息。

+ 管道
1. 它是半双⼯的，具有固定的读端和写端
2. 它只能用于父子进程或者兄弟进程之间的进程的通信
3. 它可以看成是⼀种特殊的文件，对于它的读写也可以使用普通的read、write等函数。
但是它不是普通的文件，并不属于其他任何⽂件系统，并且只存在于内存中。

+ 命名管道
1. FIFO可以在无关的进程之间交换数据，与⽆名管道不同
2. FIFO有路径名与之相关联，它以一种特殊设备⽂件形式存在于⽂件系统中

+ 消息队列
1. 消息队列，是消息的链接表，存放在内核中。⼀个消息队列由⼀个标识符ID来标识
2. 消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级
3. 消息队列独⽴立于发送与接收进程。进程终止时，消息队列及其内容并不会被删
4. 消息队列可以实现消息的随机查询，消息不一定要以先进先出的次序读取，也可以按消息的类型读取

+ 信号量
1. 信号量是⼀个计数器。⽤于实现进程间的互斥与同步，而不是⽤于存储进程间通信数据
2. 信号量用于进程间同步，若要在进程间传递数据需要结合共享内存
3. 信号量基于操作系统的PV操作，程序对信号量的操作都是原子操作
4. 每次对信号量的PV操作不仅限于对信号量值加1或减1，而且可以加减任意正整数

+ 共享内存
1. 共享内存，指两个或多个进程共享一个给定的存储区
2. 共享内存是最快的一种IPC，因为进程是直接对内存进⾏存取

### 7.进程的调度算法

调度算法是根据系统的资源分配策略所规定的资源分配算法。

+ 先来先服务调度算法

先来先服务调度算法是一种最简单的调度算法，也称为先进先出或严格排队方案。
当每个进程就绪后，它加入就绪队列。
当前正运⾏的进程停止执行，选择在就绪队列中存在时间最⻓的进程运行。

+ 时间⽚轮转调度算法

时间⽚轮转调度算法主要适⽤用于分时系统
> 分时系统：一台计算机同时为几个、几十个甚至几百个用户服务的一种操作系统。

在这种算法中，系统将所有就绪进程按到达时间的先后次序排成一个队列，
进程调度程序总是选择就绪队列中第一个进程执⾏，
即先来先服务的原则，但仅能运⾏一个时间片。

+ 短作业调度算法

短作业优先调度算法是指对短作业优先调度的算法，
从后备队列中选择一个或若⼲个估计运行时间最短的作业，将它们调⼊入内存运行。
短作业优先调度算法是一个非抢占策略，
他的原则是下一次选择预计处理时间最短的进程，因此短进程将会越过⻓作业，
跳⾄队列头。

+ 最短剩余时间优先调度算法

最短剩余时间是针对最短进程优先增加了抢占机制的版本。
在这种情况下，进程调度总是选择预期剩余时间最短的进程。当一个进程加⼊到就绪队列时，
他可能⽐当前运行的进程具有更短的剩余时间，因此只要新进程就绪，调度程序就能可能抢占当前正在运行的进程。
像最短进程优先一样，调度程序正在执行选择函数是必须有关于处理时间的估计，并且存在⻓长进程饥饿的危险。

+ 优先级调度算法

优先级调度算法每次从后备作业队列中选择优先级最髙的⼀个或几个作业，
将它们调入内存，分配必要的资源，创建进程并放入就绪队列。
在进程调度中，优先级调度算法每次从就绪队列中选择优先级最高的进程，
将处理机分配给它，使之投入运行。

## 死锁

### 1.什么是死锁？

死锁，是指多个进程在运⾏过程中因争夺资源⽽造成的一种僵局，
当进程处于这种僵持状态时，若⽆外⼒作用，它们都将无法再向前推进。
如下图所示：如果此时有一个线程A，已经持有了锁A，
但是试图获取锁B，线程B持有 锁B，而试图获取锁A，这种情况下就会产⽣生死锁。

### 2.死锁产生的必要条件

1. 互斥条件：进程要求对所分配的资源进⾏排它性控制，
即在⼀段时间内某资源仅为一进程所占用
2. 请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放
3. 不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，
只能在使用完时由⾃自⼰己释放
4. 环路等待条件：在发生死锁时，必然存在一个进程--资源的环形链


